# THIS FILE HAS BEEN AUTO-GENERATED BY "PRISMA DEPLOY"
# DO NOT EDIT THIS FILE DIRECTLY

#
# Model Types
#

type Episode implements Node {
  id: ID!
  title: String!
  date: DateTime!
  description: String!
  src: String!
  plays(where: PodcastPlayWhereInput, orderBy: PodcastPlayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PodcastPlay!]
  show(where: ShowWhereInput, orderBy: ShowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Show!]
}

type Playlist implements Node {
  id: ID!
  user(where: UserWhereInput): User!
  name: String!
  episodes(where: EpisodeWhereInput, orderBy: EpisodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Episode!]
}

type PodcastLike implements Node {
  id: ID!
  user(where: UserWhereInput): User!
  liked: Boolean!
  episode(where: EpisodeWhereInput): Episode!
}

type PodcastPlay implements Node {
  id: ID!
  user(where: UserWhereInput): User!
  progress: Float!
  episode(where: EpisodeWhereInput): Episode!
}

type Show implements Node {
  id: ID!
  title: String!
  showId: String!
  thumbLarge: String!
  episodes(where: EpisodeWhereInput, orderBy: EpisodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Episode!]
}

type User implements Node {
  id: ID!
  name: String!
  email: String!
  fbid: String!
  history(where: PodcastPlayWhereInput, orderBy: PodcastPlayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PodcastPlay!]
  likes(where: PodcastLikeWhereInput, orderBy: PodcastLikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PodcastLike!]
  playlists(where: PlaylistWhereInput, orderBy: PlaylistOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Playlist!]
}


#
# Other Types
#

type AggregateEpisode {
  count: Int!
}

type AggregatePlaylist {
  count: Int!
}

type AggregatePodcastLike {
  count: Int!
}

type AggregatePodcastPlay {
  count: Int!
}

type AggregateShow {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type EpisodeConnection {
  pageInfo: PageInfo!
  edges: [EpisodeEdge]!
  aggregate: AggregateEpisode!
}

input EpisodeCreateInput {
  title: String!
  date: DateTime!
  description: String!
  src: String!
  plays: PodcastPlayCreateManyWithoutEpisodeInput
  show: ShowCreateManyWithoutEpisodesInput
}

input EpisodeCreateManyInput {
  create: [EpisodeCreateInput!]
  connect: [EpisodeWhereUniqueInput!]
}

input EpisodeCreateManyWithoutShowInput {
  create: [EpisodeCreateWithoutShowInput!]
  connect: [EpisodeWhereUniqueInput!]
}

input EpisodeCreateOneInput {
  create: EpisodeCreateInput
  connect: EpisodeWhereUniqueInput
}

input EpisodeCreateOneWithoutPlaysInput {
  create: EpisodeCreateWithoutPlaysInput
  connect: EpisodeWhereUniqueInput
}

input EpisodeCreateWithoutPlaysInput {
  title: String!
  date: DateTime!
  description: String!
  src: String!
  show: ShowCreateManyWithoutEpisodesInput
}

input EpisodeCreateWithoutShowInput {
  title: String!
  date: DateTime!
  description: String!
  src: String!
  plays: PodcastPlayCreateManyWithoutEpisodeInput
}

type EpisodeEdge {
  node: Episode!
  cursor: String!
}

enum EpisodeOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  date_ASC
  date_DESC
  description_ASC
  description_DESC
  src_ASC
  src_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type EpisodePreviousValues {
  id: ID!
  title: String!
  date: DateTime!
  description: String!
  src: String!
}

type EpisodeSubscriptionPayload {
  mutation: MutationType!
  node: Episode
  updatedFields: [String!]
  previousValues: EpisodePreviousValues
}

input EpisodeSubscriptionWhereInput {
  AND: [EpisodeSubscriptionWhereInput!]
  OR: [EpisodeSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EpisodeWhereInput
}

input EpisodeUpdateInput {
  title: String
  date: DateTime
  description: String
  src: String
  plays: PodcastPlayUpdateManyWithoutEpisodeInput
  show: ShowUpdateManyWithoutEpisodesInput
}

input EpisodeUpdateManyInput {
  create: [EpisodeCreateInput!]
  connect: [EpisodeWhereUniqueInput!]
  disconnect: [EpisodeWhereUniqueInput!]
  delete: [EpisodeWhereUniqueInput!]
}

input EpisodeUpdateManyWithoutShowInput {
  create: [EpisodeCreateWithoutShowInput!]
  connect: [EpisodeWhereUniqueInput!]
  disconnect: [EpisodeWhereUniqueInput!]
  delete: [EpisodeWhereUniqueInput!]
  update: [EpisodeUpdateWithoutShowInput!]
  upsert: [EpisodeUpsertWithoutShowInput!]
}

input EpisodeUpdateOneInput {
  create: EpisodeCreateInput
  connect: EpisodeWhereUniqueInput
  disconnect: EpisodeWhereUniqueInput
  delete: EpisodeWhereUniqueInput
}

input EpisodeUpdateOneWithoutPlaysInput {
  create: EpisodeCreateWithoutPlaysInput
  connect: EpisodeWhereUniqueInput
  disconnect: EpisodeWhereUniqueInput
  delete: EpisodeWhereUniqueInput
  update: EpisodeUpdateWithoutPlaysInput
  upsert: EpisodeUpsertWithoutPlaysInput
}

input EpisodeUpdateWithoutPlaysDataInput {
  title: String
  date: DateTime
  description: String
  src: String
  show: ShowUpdateManyWithoutEpisodesInput
}

input EpisodeUpdateWithoutPlaysInput {
  where: EpisodeWhereUniqueInput!
  data: EpisodeUpdateWithoutPlaysDataInput!
}

input EpisodeUpdateWithoutShowDataInput {
  title: String
  date: DateTime
  description: String
  src: String
  plays: PodcastPlayUpdateManyWithoutEpisodeInput
}

input EpisodeUpdateWithoutShowInput {
  where: EpisodeWhereUniqueInput!
  data: EpisodeUpdateWithoutShowDataInput!
}

input EpisodeUpsertWithoutPlaysInput {
  where: EpisodeWhereUniqueInput!
  update: EpisodeUpdateWithoutPlaysDataInput!
  create: EpisodeCreateWithoutPlaysInput!
}

input EpisodeUpsertWithoutShowInput {
  where: EpisodeWhereUniqueInput!
  update: EpisodeUpdateWithoutShowDataInput!
  create: EpisodeCreateWithoutShowInput!
}

input EpisodeWhereInput {
  AND: [EpisodeWhereInput!]
  OR: [EpisodeWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  src: String
  src_not: String
  src_in: [String!]
  src_not_in: [String!]
  src_lt: String
  src_lte: String
  src_gt: String
  src_gte: String
  src_contains: String
  src_not_contains: String
  src_starts_with: String
  src_not_starts_with: String
  src_ends_with: String
  src_not_ends_with: String
  plays_every: PodcastPlayWhereInput
  plays_some: PodcastPlayWhereInput
  plays_none: PodcastPlayWhereInput
  show_every: ShowWhereInput
  show_some: ShowWhereInput
  show_none: ShowWhereInput
}

input EpisodeWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createShow(data: ShowCreateInput!): Show!
  createEpisode(data: EpisodeCreateInput!): Episode!
  createPodcastPlay(data: PodcastPlayCreateInput!): PodcastPlay!
  createPodcastLike(data: PodcastLikeCreateInput!): PodcastLike!
  createPlaylist(data: PlaylistCreateInput!): Playlist!
  createUser(data: UserCreateInput!): User!
  updateShow(data: ShowUpdateInput!, where: ShowWhereUniqueInput!): Show
  updateEpisode(data: EpisodeUpdateInput!, where: EpisodeWhereUniqueInput!): Episode
  updatePodcastPlay(data: PodcastPlayUpdateInput!, where: PodcastPlayWhereUniqueInput!): PodcastPlay
  updatePodcastLike(data: PodcastLikeUpdateInput!, where: PodcastLikeWhereUniqueInput!): PodcastLike
  updatePlaylist(data: PlaylistUpdateInput!, where: PlaylistWhereUniqueInput!): Playlist
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  deleteShow(where: ShowWhereUniqueInput!): Show
  deleteEpisode(where: EpisodeWhereUniqueInput!): Episode
  deletePodcastPlay(where: PodcastPlayWhereUniqueInput!): PodcastPlay
  deletePodcastLike(where: PodcastLikeWhereUniqueInput!): PodcastLike
  deletePlaylist(where: PlaylistWhereUniqueInput!): Playlist
  deleteUser(where: UserWhereUniqueInput!): User
  upsertShow(where: ShowWhereUniqueInput!, create: ShowCreateInput!, update: ShowUpdateInput!): Show!
  upsertEpisode(where: EpisodeWhereUniqueInput!, create: EpisodeCreateInput!, update: EpisodeUpdateInput!): Episode!
  upsertPodcastPlay(where: PodcastPlayWhereUniqueInput!, create: PodcastPlayCreateInput!, update: PodcastPlayUpdateInput!): PodcastPlay!
  upsertPodcastLike(where: PodcastLikeWhereUniqueInput!, create: PodcastLikeCreateInput!, update: PodcastLikeUpdateInput!): PodcastLike!
  upsertPlaylist(where: PlaylistWhereUniqueInput!, create: PlaylistCreateInput!, update: PlaylistUpdateInput!): Playlist!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  updateManyShows(data: ShowUpdateInput!, where: ShowWhereInput!): BatchPayload!
  updateManyEpisodes(data: EpisodeUpdateInput!, where: EpisodeWhereInput!): BatchPayload!
  updateManyPodcastPlays(data: PodcastPlayUpdateInput!, where: PodcastPlayWhereInput!): BatchPayload!
  updateManyPodcastLikes(data: PodcastLikeUpdateInput!, where: PodcastLikeWhereInput!): BatchPayload!
  updateManyPlaylists(data: PlaylistUpdateInput!, where: PlaylistWhereInput!): BatchPayload!
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput!): BatchPayload!
  deleteManyShows(where: ShowWhereInput!): BatchPayload!
  deleteManyEpisodes(where: EpisodeWhereInput!): BatchPayload!
  deleteManyPodcastPlays(where: PodcastPlayWhereInput!): BatchPayload!
  deleteManyPodcastLikes(where: PodcastLikeWhereInput!): BatchPayload!
  deleteManyPlaylists(where: PlaylistWhereInput!): BatchPayload!
  deleteManyUsers(where: UserWhereInput!): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PlaylistConnection {
  pageInfo: PageInfo!
  edges: [PlaylistEdge]!
  aggregate: AggregatePlaylist!
}

input PlaylistCreateInput {
  name: String!
  user: UserCreateOneWithoutPlaylistsInput!
  episodes: EpisodeCreateManyInput
}

input PlaylistCreateManyWithoutUserInput {
  create: [PlaylistCreateWithoutUserInput!]
  connect: [PlaylistWhereUniqueInput!]
}

input PlaylistCreateWithoutUserInput {
  name: String!
  episodes: EpisodeCreateManyInput
}

type PlaylistEdge {
  node: Playlist!
  cursor: String!
}

enum PlaylistOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PlaylistPreviousValues {
  id: ID!
  name: String!
}

type PlaylistSubscriptionPayload {
  mutation: MutationType!
  node: Playlist
  updatedFields: [String!]
  previousValues: PlaylistPreviousValues
}

input PlaylistSubscriptionWhereInput {
  AND: [PlaylistSubscriptionWhereInput!]
  OR: [PlaylistSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlaylistWhereInput
}

input PlaylistUpdateInput {
  name: String
  user: UserUpdateOneWithoutPlaylistsInput
  episodes: EpisodeUpdateManyInput
}

input PlaylistUpdateManyWithoutUserInput {
  create: [PlaylistCreateWithoutUserInput!]
  connect: [PlaylistWhereUniqueInput!]
  disconnect: [PlaylistWhereUniqueInput!]
  delete: [PlaylistWhereUniqueInput!]
  update: [PlaylistUpdateWithoutUserInput!]
  upsert: [PlaylistUpsertWithoutUserInput!]
}

input PlaylistUpdateWithoutUserDataInput {
  name: String
  episodes: EpisodeUpdateManyInput
}

input PlaylistUpdateWithoutUserInput {
  where: PlaylistWhereUniqueInput!
  data: PlaylistUpdateWithoutUserDataInput!
}

input PlaylistUpsertWithoutUserInput {
  where: PlaylistWhereUniqueInput!
  update: PlaylistUpdateWithoutUserDataInput!
  create: PlaylistCreateWithoutUserInput!
}

input PlaylistWhereInput {
  AND: [PlaylistWhereInput!]
  OR: [PlaylistWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  user: UserWhereInput
  episodes_every: EpisodeWhereInput
  episodes_some: EpisodeWhereInput
  episodes_none: EpisodeWhereInput
}

input PlaylistWhereUniqueInput {
  id: ID
}

type PodcastLikeConnection {
  pageInfo: PageInfo!
  edges: [PodcastLikeEdge]!
  aggregate: AggregatePodcastLike!
}

input PodcastLikeCreateInput {
  liked: Boolean
  user: UserCreateOneWithoutLikesInput!
  episode: EpisodeCreateOneInput!
}

input PodcastLikeCreateManyWithoutUserInput {
  create: [PodcastLikeCreateWithoutUserInput!]
  connect: [PodcastLikeWhereUniqueInput!]
}

input PodcastLikeCreateWithoutUserInput {
  liked: Boolean
  episode: EpisodeCreateOneInput!
}

type PodcastLikeEdge {
  node: PodcastLike!
  cursor: String!
}

enum PodcastLikeOrderByInput {
  id_ASC
  id_DESC
  liked_ASC
  liked_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PodcastLikePreviousValues {
  id: ID!
  liked: Boolean!
}

type PodcastLikeSubscriptionPayload {
  mutation: MutationType!
  node: PodcastLike
  updatedFields: [String!]
  previousValues: PodcastLikePreviousValues
}

input PodcastLikeSubscriptionWhereInput {
  AND: [PodcastLikeSubscriptionWhereInput!]
  OR: [PodcastLikeSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PodcastLikeWhereInput
}

input PodcastLikeUpdateInput {
  liked: Boolean
  user: UserUpdateOneWithoutLikesInput
  episode: EpisodeUpdateOneInput
}

input PodcastLikeUpdateManyWithoutUserInput {
  create: [PodcastLikeCreateWithoutUserInput!]
  connect: [PodcastLikeWhereUniqueInput!]
  disconnect: [PodcastLikeWhereUniqueInput!]
  delete: [PodcastLikeWhereUniqueInput!]
  update: [PodcastLikeUpdateWithoutUserInput!]
  upsert: [PodcastLikeUpsertWithoutUserInput!]
}

input PodcastLikeUpdateWithoutUserDataInput {
  liked: Boolean
  episode: EpisodeUpdateOneInput
}

input PodcastLikeUpdateWithoutUserInput {
  where: PodcastLikeWhereUniqueInput!
  data: PodcastLikeUpdateWithoutUserDataInput!
}

input PodcastLikeUpsertWithoutUserInput {
  where: PodcastLikeWhereUniqueInput!
  update: PodcastLikeUpdateWithoutUserDataInput!
  create: PodcastLikeCreateWithoutUserInput!
}

input PodcastLikeWhereInput {
  AND: [PodcastLikeWhereInput!]
  OR: [PodcastLikeWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  liked: Boolean
  liked_not: Boolean
  user: UserWhereInput
  episode: EpisodeWhereInput
}

input PodcastLikeWhereUniqueInput {
  id: ID
}

type PodcastPlayConnection {
  pageInfo: PageInfo!
  edges: [PodcastPlayEdge]!
  aggregate: AggregatePodcastPlay!
}

input PodcastPlayCreateInput {
  progress: Float
  user: UserCreateOneWithoutHistoryInput!
  episode: EpisodeCreateOneWithoutPlaysInput!
}

input PodcastPlayCreateManyWithoutEpisodeInput {
  create: [PodcastPlayCreateWithoutEpisodeInput!]
  connect: [PodcastPlayWhereUniqueInput!]
}

input PodcastPlayCreateManyWithoutUserInput {
  create: [PodcastPlayCreateWithoutUserInput!]
  connect: [PodcastPlayWhereUniqueInput!]
}

input PodcastPlayCreateWithoutEpisodeInput {
  progress: Float
  user: UserCreateOneWithoutHistoryInput!
}

input PodcastPlayCreateWithoutUserInput {
  progress: Float
  episode: EpisodeCreateOneWithoutPlaysInput!
}

type PodcastPlayEdge {
  node: PodcastPlay!
  cursor: String!
}

enum PodcastPlayOrderByInput {
  id_ASC
  id_DESC
  progress_ASC
  progress_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PodcastPlayPreviousValues {
  id: ID!
  progress: Float!
}

type PodcastPlaySubscriptionPayload {
  mutation: MutationType!
  node: PodcastPlay
  updatedFields: [String!]
  previousValues: PodcastPlayPreviousValues
}

input PodcastPlaySubscriptionWhereInput {
  AND: [PodcastPlaySubscriptionWhereInput!]
  OR: [PodcastPlaySubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PodcastPlayWhereInput
}

input PodcastPlayUpdateInput {
  progress: Float
  user: UserUpdateOneWithoutHistoryInput
  episode: EpisodeUpdateOneWithoutPlaysInput
}

input PodcastPlayUpdateManyWithoutEpisodeInput {
  create: [PodcastPlayCreateWithoutEpisodeInput!]
  connect: [PodcastPlayWhereUniqueInput!]
  disconnect: [PodcastPlayWhereUniqueInput!]
  delete: [PodcastPlayWhereUniqueInput!]
  update: [PodcastPlayUpdateWithoutEpisodeInput!]
  upsert: [PodcastPlayUpsertWithoutEpisodeInput!]
}

input PodcastPlayUpdateManyWithoutUserInput {
  create: [PodcastPlayCreateWithoutUserInput!]
  connect: [PodcastPlayWhereUniqueInput!]
  disconnect: [PodcastPlayWhereUniqueInput!]
  delete: [PodcastPlayWhereUniqueInput!]
  update: [PodcastPlayUpdateWithoutUserInput!]
  upsert: [PodcastPlayUpsertWithoutUserInput!]
}

input PodcastPlayUpdateWithoutEpisodeDataInput {
  progress: Float
  user: UserUpdateOneWithoutHistoryInput
}

input PodcastPlayUpdateWithoutEpisodeInput {
  where: PodcastPlayWhereUniqueInput!
  data: PodcastPlayUpdateWithoutEpisodeDataInput!
}

input PodcastPlayUpdateWithoutUserDataInput {
  progress: Float
  episode: EpisodeUpdateOneWithoutPlaysInput
}

input PodcastPlayUpdateWithoutUserInput {
  where: PodcastPlayWhereUniqueInput!
  data: PodcastPlayUpdateWithoutUserDataInput!
}

input PodcastPlayUpsertWithoutEpisodeInput {
  where: PodcastPlayWhereUniqueInput!
  update: PodcastPlayUpdateWithoutEpisodeDataInput!
  create: PodcastPlayCreateWithoutEpisodeInput!
}

input PodcastPlayUpsertWithoutUserInput {
  where: PodcastPlayWhereUniqueInput!
  update: PodcastPlayUpdateWithoutUserDataInput!
  create: PodcastPlayCreateWithoutUserInput!
}

input PodcastPlayWhereInput {
  AND: [PodcastPlayWhereInput!]
  OR: [PodcastPlayWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  progress: Float
  progress_not: Float
  progress_in: [Float!]
  progress_not_in: [Float!]
  progress_lt: Float
  progress_lte: Float
  progress_gt: Float
  progress_gte: Float
  user: UserWhereInput
  episode: EpisodeWhereInput
}

input PodcastPlayWhereUniqueInput {
  id: ID
}

type Query {
  shows(where: ShowWhereInput, orderBy: ShowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Show]!
  episodes(where: EpisodeWhereInput, orderBy: EpisodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Episode]!
  podcastPlays(where: PodcastPlayWhereInput, orderBy: PodcastPlayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PodcastPlay]!
  podcastLikes(where: PodcastLikeWhereInput, orderBy: PodcastLikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PodcastLike]!
  playlists(where: PlaylistWhereInput, orderBy: PlaylistOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Playlist]!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  show(where: ShowWhereUniqueInput!): Show
  episode(where: EpisodeWhereUniqueInput!): Episode
  podcastPlay(where: PodcastPlayWhereUniqueInput!): PodcastPlay
  podcastLike(where: PodcastLikeWhereUniqueInput!): PodcastLike
  playlist(where: PlaylistWhereUniqueInput!): Playlist
  user(where: UserWhereUniqueInput!): User
  showsConnection(where: ShowWhereInput, orderBy: ShowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ShowConnection!
  episodesConnection(where: EpisodeWhereInput, orderBy: EpisodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EpisodeConnection!
  podcastPlaysConnection(where: PodcastPlayWhereInput, orderBy: PodcastPlayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PodcastPlayConnection!
  podcastLikesConnection(where: PodcastLikeWhereInput, orderBy: PodcastLikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PodcastLikeConnection!
  playlistsConnection(where: PlaylistWhereInput, orderBy: PlaylistOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlaylistConnection!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type ShowConnection {
  pageInfo: PageInfo!
  edges: [ShowEdge]!
  aggregate: AggregateShow!
}

input ShowCreateInput {
  title: String!
  showId: String!
  thumbLarge: String!
  episodes: EpisodeCreateManyWithoutShowInput
}

input ShowCreateManyWithoutEpisodesInput {
  create: [ShowCreateWithoutEpisodesInput!]
  connect: [ShowWhereUniqueInput!]
}

input ShowCreateWithoutEpisodesInput {
  title: String!
  showId: String!
  thumbLarge: String!
}

type ShowEdge {
  node: Show!
  cursor: String!
}

enum ShowOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  showId_ASC
  showId_DESC
  thumbLarge_ASC
  thumbLarge_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type ShowPreviousValues {
  id: ID!
  title: String!
  showId: String!
  thumbLarge: String!
}

type ShowSubscriptionPayload {
  mutation: MutationType!
  node: Show
  updatedFields: [String!]
  previousValues: ShowPreviousValues
}

input ShowSubscriptionWhereInput {
  AND: [ShowSubscriptionWhereInput!]
  OR: [ShowSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ShowWhereInput
}

input ShowUpdateInput {
  title: String
  showId: String
  thumbLarge: String
  episodes: EpisodeUpdateManyWithoutShowInput
}

input ShowUpdateManyWithoutEpisodesInput {
  create: [ShowCreateWithoutEpisodesInput!]
  connect: [ShowWhereUniqueInput!]
  disconnect: [ShowWhereUniqueInput!]
  delete: [ShowWhereUniqueInput!]
  update: [ShowUpdateWithoutEpisodesInput!]
  upsert: [ShowUpsertWithoutEpisodesInput!]
}

input ShowUpdateWithoutEpisodesDataInput {
  title: String
  showId: String
  thumbLarge: String
}

input ShowUpdateWithoutEpisodesInput {
  where: ShowWhereUniqueInput!
  data: ShowUpdateWithoutEpisodesDataInput!
}

input ShowUpsertWithoutEpisodesInput {
  where: ShowWhereUniqueInput!
  update: ShowUpdateWithoutEpisodesDataInput!
  create: ShowCreateWithoutEpisodesInput!
}

input ShowWhereInput {
  AND: [ShowWhereInput!]
  OR: [ShowWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  showId: String
  showId_not: String
  showId_in: [String!]
  showId_not_in: [String!]
  showId_lt: String
  showId_lte: String
  showId_gt: String
  showId_gte: String
  showId_contains: String
  showId_not_contains: String
  showId_starts_with: String
  showId_not_starts_with: String
  showId_ends_with: String
  showId_not_ends_with: String
  thumbLarge: String
  thumbLarge_not: String
  thumbLarge_in: [String!]
  thumbLarge_not_in: [String!]
  thumbLarge_lt: String
  thumbLarge_lte: String
  thumbLarge_gt: String
  thumbLarge_gte: String
  thumbLarge_contains: String
  thumbLarge_not_contains: String
  thumbLarge_starts_with: String
  thumbLarge_not_starts_with: String
  thumbLarge_ends_with: String
  thumbLarge_not_ends_with: String
  episodes_every: EpisodeWhereInput
  episodes_some: EpisodeWhereInput
  episodes_none: EpisodeWhereInput
}

input ShowWhereUniqueInput {
  id: ID
  showId: String
}

type Subscription {
  show(where: ShowSubscriptionWhereInput): ShowSubscriptionPayload
  episode(where: EpisodeSubscriptionWhereInput): EpisodeSubscriptionPayload
  podcastPlay(where: PodcastPlaySubscriptionWhereInput): PodcastPlaySubscriptionPayload
  podcastLike(where: PodcastLikeSubscriptionWhereInput): PodcastLikeSubscriptionPayload
  playlist(where: PlaylistSubscriptionWhereInput): PlaylistSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  name: String!
  email: String!
  fbid: String!
  history: PodcastPlayCreateManyWithoutUserInput
  likes: PodcastLikeCreateManyWithoutUserInput
  playlists: PlaylistCreateManyWithoutUserInput
}

input UserCreateOneWithoutHistoryInput {
  create: UserCreateWithoutHistoryInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutLikesInput {
  create: UserCreateWithoutLikesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPlaylistsInput {
  create: UserCreateWithoutPlaylistsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutHistoryInput {
  name: String!
  email: String!
  fbid: String!
  likes: PodcastLikeCreateManyWithoutUserInput
  playlists: PlaylistCreateManyWithoutUserInput
}

input UserCreateWithoutLikesInput {
  name: String!
  email: String!
  fbid: String!
  history: PodcastPlayCreateManyWithoutUserInput
  playlists: PlaylistCreateManyWithoutUserInput
}

input UserCreateWithoutPlaylistsInput {
  name: String!
  email: String!
  fbid: String!
  history: PodcastPlayCreateManyWithoutUserInput
  likes: PodcastLikeCreateManyWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  fbid_ASC
  fbid_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  fbid: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
}

input UserUpdateInput {
  name: String
  email: String
  fbid: String
  history: PodcastPlayUpdateManyWithoutUserInput
  likes: PodcastLikeUpdateManyWithoutUserInput
  playlists: PlaylistUpdateManyWithoutUserInput
}

input UserUpdateOneWithoutHistoryInput {
  create: UserCreateWithoutHistoryInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutHistoryInput
  upsert: UserUpsertWithoutHistoryInput
}

input UserUpdateOneWithoutLikesInput {
  create: UserCreateWithoutLikesInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutLikesInput
  upsert: UserUpsertWithoutLikesInput
}

input UserUpdateOneWithoutPlaylistsInput {
  create: UserCreateWithoutPlaylistsInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutPlaylistsInput
  upsert: UserUpsertWithoutPlaylistsInput
}

input UserUpdateWithoutHistoryDataInput {
  name: String
  email: String
  fbid: String
  likes: PodcastLikeUpdateManyWithoutUserInput
  playlists: PlaylistUpdateManyWithoutUserInput
}

input UserUpdateWithoutHistoryInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutHistoryDataInput!
}

input UserUpdateWithoutLikesDataInput {
  name: String
  email: String
  fbid: String
  history: PodcastPlayUpdateManyWithoutUserInput
  playlists: PlaylistUpdateManyWithoutUserInput
}

input UserUpdateWithoutLikesInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutLikesDataInput!
}

input UserUpdateWithoutPlaylistsDataInput {
  name: String
  email: String
  fbid: String
  history: PodcastPlayUpdateManyWithoutUserInput
  likes: PodcastLikeUpdateManyWithoutUserInput
}

input UserUpdateWithoutPlaylistsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutPlaylistsDataInput!
}

input UserUpsertWithoutHistoryInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutHistoryDataInput!
  create: UserCreateWithoutHistoryInput!
}

input UserUpsertWithoutLikesInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutLikesDataInput!
  create: UserCreateWithoutLikesInput!
}

input UserUpsertWithoutPlaylistsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutPlaylistsDataInput!
  create: UserCreateWithoutPlaylistsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  fbid: String
  fbid_not: String
  fbid_in: [String!]
  fbid_not_in: [String!]
  fbid_lt: String
  fbid_lte: String
  fbid_gt: String
  fbid_gte: String
  fbid_contains: String
  fbid_not_contains: String
  fbid_starts_with: String
  fbid_not_starts_with: String
  fbid_ends_with: String
  fbid_not_ends_with: String
  history_every: PodcastPlayWhereInput
  history_some: PodcastPlayWhereInput
  history_none: PodcastPlayWhereInput
  likes_every: PodcastLikeWhereInput
  likes_some: PodcastLikeWhereInput
  likes_none: PodcastLikeWhereInput
  playlists_every: PlaylistWhereInput
  playlists_some: PlaylistWhereInput
  playlists_none: PlaylistWhereInput
}

input UserWhereUniqueInput {
  id: ID
  email: String
  fbid: String
}
