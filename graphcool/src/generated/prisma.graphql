# THIS FILE HAS BEEN AUTO-GENERATED BY "PRISMA DEPLOY"
# DO NOT EDIT THIS FILE DIRECTLY

#
# Model Types
#

type Episode implements Node {
  id: ID!
  title: String!
  date: DateTime!
  description: String!
  src: String!
  ha: String!
  plays(where: PodcastPlayWhereInput, orderBy: PodcastPlayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PodcastPlay!]
  show(where: ShowWhereInput, orderBy: ShowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Show!]
}

type PodcastPlay implements Node {
  id: ID!
  user(where: UserWhereInput): User!
  progress: Float
  episode(where: EpisodeWhereInput): Episode!
}

type Show implements Node {
  id: ID!
  title: String!
  showId: String!
  thumbLarge: String!
  episodes(where: EpisodeWhereInput, orderBy: EpisodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Episode!]
}

type User implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  facebookUserId: String!
  email: String!
}


#
# Other Types
#

type AggregateEpisode {
  count: Int!
}

type AggregatePodcastPlay {
  count: Int!
}

type AggregateShow {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type EpisodeConnection {
  pageInfo: PageInfo!
  edges: [EpisodeEdge]!
  aggregate: AggregateEpisode!
}

input EpisodeCreateInput {
  title: String!
  date: DateTime!
  description: String!
  src: String!
  ha: String!
  plays: PodcastPlayCreateManyWithoutEpisodeInput
  show: ShowCreateManyWithoutEpisodesInput
}

input EpisodeCreateManyWithoutShowInput {
  create: [EpisodeCreateWithoutShowInput!]
  connect: [EpisodeWhereUniqueInput!]
}

input EpisodeCreateOneWithoutPlaysInput {
  create: EpisodeCreateWithoutPlaysInput
  connect: EpisodeWhereUniqueInput
}

input EpisodeCreateWithoutPlaysInput {
  title: String!
  date: DateTime!
  description: String!
  src: String!
  ha: String!
  show: ShowCreateManyWithoutEpisodesInput
}

input EpisodeCreateWithoutShowInput {
  title: String!
  date: DateTime!
  description: String!
  src: String!
  ha: String!
  plays: PodcastPlayCreateManyWithoutEpisodeInput
}

type EpisodeEdge {
  node: Episode!
  cursor: String!
}

enum EpisodeOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  date_ASC
  date_DESC
  description_ASC
  description_DESC
  src_ASC
  src_DESC
  ha_ASC
  ha_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type EpisodePreviousValues {
  id: ID!
  title: String!
  date: DateTime!
  description: String!
  src: String!
  ha: String!
}

type EpisodeSubscriptionPayload {
  mutation: MutationType!
  node: Episode
  updatedFields: [String!]
  previousValues: EpisodePreviousValues
}

input EpisodeSubscriptionWhereInput {
  AND: [EpisodeSubscriptionWhereInput!]
  OR: [EpisodeSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EpisodeWhereInput
}

input EpisodeUpdateInput {
  title: String
  date: DateTime
  description: String
  src: String
  ha: String
  plays: PodcastPlayUpdateManyWithoutEpisodeInput
  show: ShowUpdateManyWithoutEpisodesInput
}

input EpisodeUpdateManyWithoutShowInput {
  create: [EpisodeCreateWithoutShowInput!]
  connect: [EpisodeWhereUniqueInput!]
  disconnect: [EpisodeWhereUniqueInput!]
  delete: [EpisodeWhereUniqueInput!]
  update: [EpisodeUpdateWithoutShowInput!]
  upsert: [EpisodeUpsertWithoutShowInput!]
}

input EpisodeUpdateOneWithoutPlaysInput {
  create: EpisodeCreateWithoutPlaysInput
  connect: EpisodeWhereUniqueInput
  disconnect: EpisodeWhereUniqueInput
  delete: EpisodeWhereUniqueInput
  update: EpisodeUpdateWithoutPlaysInput
  upsert: EpisodeUpsertWithoutPlaysInput
}

input EpisodeUpdateWithoutPlaysDataInput {
  title: String
  date: DateTime
  description: String
  src: String
  ha: String
  show: ShowUpdateManyWithoutEpisodesInput
}

input EpisodeUpdateWithoutPlaysInput {
  where: EpisodeWhereUniqueInput!
  data: EpisodeUpdateWithoutPlaysDataInput!
}

input EpisodeUpdateWithoutShowDataInput {
  title: String
  date: DateTime
  description: String
  src: String
  ha: String
  plays: PodcastPlayUpdateManyWithoutEpisodeInput
}

input EpisodeUpdateWithoutShowInput {
  where: EpisodeWhereUniqueInput!
  data: EpisodeUpdateWithoutShowDataInput!
}

input EpisodeUpsertWithoutPlaysInput {
  where: EpisodeWhereUniqueInput!
  update: EpisodeUpdateWithoutPlaysDataInput!
  create: EpisodeCreateWithoutPlaysInput!
}

input EpisodeUpsertWithoutShowInput {
  where: EpisodeWhereUniqueInput!
  update: EpisodeUpdateWithoutShowDataInput!
  create: EpisodeCreateWithoutShowInput!
}

input EpisodeWhereInput {
  AND: [EpisodeWhereInput!]
  OR: [EpisodeWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  src: String
  src_not: String
  src_in: [String!]
  src_not_in: [String!]
  src_lt: String
  src_lte: String
  src_gt: String
  src_gte: String
  src_contains: String
  src_not_contains: String
  src_starts_with: String
  src_not_starts_with: String
  src_ends_with: String
  src_not_ends_with: String
  ha: String
  ha_not: String
  ha_in: [String!]
  ha_not_in: [String!]
  ha_lt: String
  ha_lte: String
  ha_gt: String
  ha_gte: String
  ha_contains: String
  ha_not_contains: String
  ha_starts_with: String
  ha_not_starts_with: String
  ha_ends_with: String
  ha_not_ends_with: String
  plays_every: PodcastPlayWhereInput
  plays_some: PodcastPlayWhereInput
  plays_none: PodcastPlayWhereInput
  show_every: ShowWhereInput
  show_some: ShowWhereInput
  show_none: ShowWhereInput
}

input EpisodeWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createUser(data: UserCreateInput!): User!
  createShow(data: ShowCreateInput!): Show!
  createEpisode(data: EpisodeCreateInput!): Episode!
  createPodcastPlay(data: PodcastPlayCreateInput!): PodcastPlay!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateShow(data: ShowUpdateInput!, where: ShowWhereUniqueInput!): Show
  updateEpisode(data: EpisodeUpdateInput!, where: EpisodeWhereUniqueInput!): Episode
  updatePodcastPlay(data: PodcastPlayUpdateInput!, where: PodcastPlayWhereUniqueInput!): PodcastPlay
  deleteUser(where: UserWhereUniqueInput!): User
  deleteShow(where: ShowWhereUniqueInput!): Show
  deleteEpisode(where: EpisodeWhereUniqueInput!): Episode
  deletePodcastPlay(where: PodcastPlayWhereUniqueInput!): PodcastPlay
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  upsertShow(where: ShowWhereUniqueInput!, create: ShowCreateInput!, update: ShowUpdateInput!): Show!
  upsertEpisode(where: EpisodeWhereUniqueInput!, create: EpisodeCreateInput!, update: EpisodeUpdateInput!): Episode!
  upsertPodcastPlay(where: PodcastPlayWhereUniqueInput!, create: PodcastPlayCreateInput!, update: PodcastPlayUpdateInput!): PodcastPlay!
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput!): BatchPayload!
  updateManyShows(data: ShowUpdateInput!, where: ShowWhereInput!): BatchPayload!
  updateManyEpisodes(data: EpisodeUpdateInput!, where: EpisodeWhereInput!): BatchPayload!
  updateManyPodcastPlays(data: PodcastPlayUpdateInput!, where: PodcastPlayWhereInput!): BatchPayload!
  deleteManyUsers(where: UserWhereInput!): BatchPayload!
  deleteManyShows(where: ShowWhereInput!): BatchPayload!
  deleteManyEpisodes(where: EpisodeWhereInput!): BatchPayload!
  deleteManyPodcastPlays(where: PodcastPlayWhereInput!): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PodcastPlayConnection {
  pageInfo: PageInfo!
  edges: [PodcastPlayEdge]!
  aggregate: AggregatePodcastPlay!
}

input PodcastPlayCreateInput {
  progress: Float
  user: UserCreateOneInput!
  episode: EpisodeCreateOneWithoutPlaysInput!
}

input PodcastPlayCreateManyWithoutEpisodeInput {
  create: [PodcastPlayCreateWithoutEpisodeInput!]
  connect: [PodcastPlayWhereUniqueInput!]
}

input PodcastPlayCreateWithoutEpisodeInput {
  progress: Float
  user: UserCreateOneInput!
}

type PodcastPlayEdge {
  node: PodcastPlay!
  cursor: String!
}

enum PodcastPlayOrderByInput {
  id_ASC
  id_DESC
  progress_ASC
  progress_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PodcastPlayPreviousValues {
  id: ID!
  progress: Float
}

type PodcastPlaySubscriptionPayload {
  mutation: MutationType!
  node: PodcastPlay
  updatedFields: [String!]
  previousValues: PodcastPlayPreviousValues
}

input PodcastPlaySubscriptionWhereInput {
  AND: [PodcastPlaySubscriptionWhereInput!]
  OR: [PodcastPlaySubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PodcastPlayWhereInput
}

input PodcastPlayUpdateInput {
  progress: Float
  user: UserUpdateOneInput
  episode: EpisodeUpdateOneWithoutPlaysInput
}

input PodcastPlayUpdateManyWithoutEpisodeInput {
  create: [PodcastPlayCreateWithoutEpisodeInput!]
  connect: [PodcastPlayWhereUniqueInput!]
  disconnect: [PodcastPlayWhereUniqueInput!]
  delete: [PodcastPlayWhereUniqueInput!]
  update: [PodcastPlayUpdateWithoutEpisodeInput!]
  upsert: [PodcastPlayUpsertWithoutEpisodeInput!]
}

input PodcastPlayUpdateWithoutEpisodeDataInput {
  progress: Float
  user: UserUpdateOneInput
}

input PodcastPlayUpdateWithoutEpisodeInput {
  where: PodcastPlayWhereUniqueInput!
  data: PodcastPlayUpdateWithoutEpisodeDataInput!
}

input PodcastPlayUpsertWithoutEpisodeInput {
  where: PodcastPlayWhereUniqueInput!
  update: PodcastPlayUpdateWithoutEpisodeDataInput!
  create: PodcastPlayCreateWithoutEpisodeInput!
}

input PodcastPlayWhereInput {
  AND: [PodcastPlayWhereInput!]
  OR: [PodcastPlayWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  progress: Float
  progress_not: Float
  progress_in: [Float!]
  progress_not_in: [Float!]
  progress_lt: Float
  progress_lte: Float
  progress_gt: Float
  progress_gte: Float
  user: UserWhereInput
  episode: EpisodeWhereInput
}

input PodcastPlayWhereUniqueInput {
  id: ID
}

type Query {
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  shows(where: ShowWhereInput, orderBy: ShowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Show]!
  episodes(where: EpisodeWhereInput, orderBy: EpisodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Episode]!
  podcastPlays(where: PodcastPlayWhereInput, orderBy: PodcastPlayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PodcastPlay]!
  user(where: UserWhereUniqueInput!): User
  show(where: ShowWhereUniqueInput!): Show
  episode(where: EpisodeWhereUniqueInput!): Episode
  podcastPlay(where: PodcastPlayWhereUniqueInput!): PodcastPlay
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  showsConnection(where: ShowWhereInput, orderBy: ShowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ShowConnection!
  episodesConnection(where: EpisodeWhereInput, orderBy: EpisodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EpisodeConnection!
  podcastPlaysConnection(where: PodcastPlayWhereInput, orderBy: PodcastPlayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PodcastPlayConnection!
  node(id: ID!): Node
}

type ShowConnection {
  pageInfo: PageInfo!
  edges: [ShowEdge]!
  aggregate: AggregateShow!
}

input ShowCreateInput {
  title: String!
  showId: String!
  thumbLarge: String!
  episodes: EpisodeCreateManyWithoutShowInput
}

input ShowCreateManyWithoutEpisodesInput {
  create: [ShowCreateWithoutEpisodesInput!]
  connect: [ShowWhereUniqueInput!]
}

input ShowCreateWithoutEpisodesInput {
  title: String!
  showId: String!
  thumbLarge: String!
}

type ShowEdge {
  node: Show!
  cursor: String!
}

enum ShowOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  showId_ASC
  showId_DESC
  thumbLarge_ASC
  thumbLarge_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type ShowPreviousValues {
  id: ID!
  title: String!
  showId: String!
  thumbLarge: String!
}

type ShowSubscriptionPayload {
  mutation: MutationType!
  node: Show
  updatedFields: [String!]
  previousValues: ShowPreviousValues
}

input ShowSubscriptionWhereInput {
  AND: [ShowSubscriptionWhereInput!]
  OR: [ShowSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ShowWhereInput
}

input ShowUpdateInput {
  title: String
  showId: String
  thumbLarge: String
  episodes: EpisodeUpdateManyWithoutShowInput
}

input ShowUpdateManyWithoutEpisodesInput {
  create: [ShowCreateWithoutEpisodesInput!]
  connect: [ShowWhereUniqueInput!]
  disconnect: [ShowWhereUniqueInput!]
  delete: [ShowWhereUniqueInput!]
  update: [ShowUpdateWithoutEpisodesInput!]
  upsert: [ShowUpsertWithoutEpisodesInput!]
}

input ShowUpdateWithoutEpisodesDataInput {
  title: String
  showId: String
  thumbLarge: String
}

input ShowUpdateWithoutEpisodesInput {
  where: ShowWhereUniqueInput!
  data: ShowUpdateWithoutEpisodesDataInput!
}

input ShowUpsertWithoutEpisodesInput {
  where: ShowWhereUniqueInput!
  update: ShowUpdateWithoutEpisodesDataInput!
  create: ShowCreateWithoutEpisodesInput!
}

input ShowWhereInput {
  AND: [ShowWhereInput!]
  OR: [ShowWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  showId: String
  showId_not: String
  showId_in: [String!]
  showId_not_in: [String!]
  showId_lt: String
  showId_lte: String
  showId_gt: String
  showId_gte: String
  showId_contains: String
  showId_not_contains: String
  showId_starts_with: String
  showId_not_starts_with: String
  showId_ends_with: String
  showId_not_ends_with: String
  thumbLarge: String
  thumbLarge_not: String
  thumbLarge_in: [String!]
  thumbLarge_not_in: [String!]
  thumbLarge_lt: String
  thumbLarge_lte: String
  thumbLarge_gt: String
  thumbLarge_gte: String
  thumbLarge_contains: String
  thumbLarge_not_contains: String
  thumbLarge_starts_with: String
  thumbLarge_not_starts_with: String
  thumbLarge_ends_with: String
  thumbLarge_not_ends_with: String
  episodes_every: EpisodeWhereInput
  episodes_some: EpisodeWhereInput
  episodes_none: EpisodeWhereInput
}

input ShowWhereUniqueInput {
  id: ID
  showId: String
}

type Subscription {
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  show(where: ShowSubscriptionWhereInput): ShowSubscriptionPayload
  episode(where: EpisodeSubscriptionWhereInput): EpisodeSubscriptionPayload
  podcastPlay(where: PodcastPlaySubscriptionWhereInput): PodcastPlaySubscriptionPayload
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  facebookUserId: String!
  email: String!
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  facebookUserId_ASC
  facebookUserId_DESC
  email_ASC
  email_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  facebookUserId: String!
  email: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
}

input UserUpdateInput {
  facebookUserId: String
  email: String
}

input UserUpdateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  facebookUserId: String
  facebookUserId_not: String
  facebookUserId_in: [String!]
  facebookUserId_not_in: [String!]
  facebookUserId_lt: String
  facebookUserId_lte: String
  facebookUserId_gt: String
  facebookUserId_gte: String
  facebookUserId_contains: String
  facebookUserId_not_contains: String
  facebookUserId_starts_with: String
  facebookUserId_not_starts_with: String
  facebookUserId_ends_with: String
  facebookUserId_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
}

input UserWhereUniqueInput {
  id: ID
  facebookUserId: String
}
